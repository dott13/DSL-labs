# Report: Abstract Syntax Tree (AST) Generation

## Objective

1. Get familiar with parsing, what it is and how it can be programmed [1].
2. Get familiar with the concept of AST [2].
3. In addition to what has been done in the 3rd lab work do the following:
   1. In case you didn't have a type that denotes the possible types of tokens you need to:
      1. Have a type **_TokenType_** (like an enum) that can be used in the lexical analysis to categorize the tokens.
      2. Please use regular expressions to identify the type of the token.
   2. Implement the necessary data structures for an AST that could be used for the text you have processed in the 3rd lab work.
   3. Implement a simple parser program that could extract the syntactic information from the input text.

## Results and Implementation

### Lexer

We implemented a lexer using regular expressions to tokenize the input text into tokens such as integers, floats, operators, parentheses, variables, and functions.

For this we used the code from lab3 of our [lexer.py](/lab3/lexer.py) with addition of a function called tokenizer that I basically made to convert it to tokens for parsing and not displaying.

```python
def tokenize(self):
        tokens = []
        while True:
            token = self.get_next_token()
            tokens.append(token)
            if token.type == TOKEN_EOF:
                break
        return tokens
```

### Parser

The parser takes the tokens generated by the lexer and constructs an AST based on the syntax of the input expression. We defined grammar rules and used recursive descent parsing to build the tree structure. We just take the tokens that where parsed in the text and try to get of what node what child is, this is made with a special class we design to know which child from what parent is that I called `ASTNode`.

In parser we have different methods to make it work perfectly. So we have `parse()` method to make it displayable and actually parse our text where it verifies the expression with our `expression()` function, this function also uses othe function to know what child the node is.

```python
def expression(self):
node = self.term()

        while self.current_token.type in (TOKEN_PLUS, TOKEN_MINUS):
            token = self.current_token
            if token.type == TOKEN_PLUS:
                self.eat(TOKEN_PLUS)
            elif token.type == TOKEN_MINUS:
                self.eat(TOKEN_MINUS)

            node = ASTNode(token.value, left=node, right=self.term())

        return node

    def parse(self):
        self.current_token = self.tokens[self.token_index]
        return self.expression()
```

### Abstract Syntax Tree (AST)

The AST is represented using `ASTNode` objects, where each node corresponds to an operation or operand in the expression. We used a recursive approach to construct the tree, with each node having references to its left and right children.

```python
class ASTNode:
    def __init__(self, type, value=None, args=None, left=None, right=None):
        self.type = type
        self.value = value
        self.args = args
        self.left = left
        self.right = right

    def __str__(self):
        return f'ASTNode(type={self.type}, value={self.value}, args={self.args}, left={self.left}, right={self.right})'
```

### Visualization

We added functionality to visualize the AST in a tree-like format to aid in understanding the structure of the expression.

```python
from my_parser import Parser
if __name__ == "__main__":
    text = '3 + 4 * (2 - 1)'
    parser = Parser(text)
    ast = parser.parse()
    print(ast)
```

## Output

This is our AST with the nodes of the text we took out.

```
ASTNode(type=+, value=None, args=None, left=ASTNode(type=INTEGER, value=3, args=None, left=None, right=None), right=ASTNode(type=*, value=None, args=None, left=ASTNode(type=INTEGER, value=4, args=None, left=None, right=None), right=ASTNode(type=-, value=None, args=None, left=ASTNode(type=INTEGER, value=2, args=None, left=None, right=None), right=ASTNode(type=INTEGER, value=1, args=None, left=None, right=None))))
```

## Conclusion

By implementing a lexer, parser, and AST generation, we successfully transformed a mathematical expression into a structured tree representation. This approach provides a foundation for further analysis of how are words and etc analyzed to launch our program code.
